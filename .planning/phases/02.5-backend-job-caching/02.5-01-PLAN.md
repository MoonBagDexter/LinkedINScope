---
phase: 02.5-backend-job-caching
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260202_add_job_caching.sql
  - supabase/functions/job-sync/index.ts
autonomous: false

user_setup:
  - service: supabase-cli
    why: "Edge Function deployment requires Supabase CLI authentication"
    env_vars:
      - name: SUPABASE_ACCESS_TOKEN
        source: "Supabase Dashboard -> Account -> Access Tokens -> Generate"
    dashboard_config:
      - task: "Link project to CLI"
        location: "Run: supabase link --project-ref YOUR_PROJECT_REF"
  - service: jsearch
    why: "JSearch API key needed in Edge Function secrets"
    env_vars:
      - name: JSEARCH_API_KEY
        source: "Already have from Phase 1 - same key used in VITE_JSEARCH_API_KEY"
    dashboard_config:
      - task: "Add JSEARCH_API_KEY to Edge Function secrets"
        location: "Supabase Dashboard -> Edge Functions -> Secrets OR via CLI: supabase secrets set JSEARCH_API_KEY=your_key"

must_haves:
  truths:
    - "Database schema has all JSearch job fields"
    - "Edge Function code exists and compiles"
    - "Migration file is idempotent (can run multiple times safely)"
  artifacts:
    - path: "supabase/functions/job-sync/index.ts"
      provides: "Edge Function handler for job sync"
      contains: "Deno.serve"
    - path: "supabase/migrations/20260202_add_job_caching.sql"
      provides: "Schema migration for all JSearch fields + caching columns"
      contains: "job_title"
  key_links:
    - from: "supabase/functions/job-sync/index.ts"
      to: "JSearch API"
      via: "fetch with X-RapidAPI headers"
      pattern: "jsearch.p.rapidapi.com"
    - from: "supabase/functions/job-sync/index.ts"
      to: "Supabase jobs table"
      via: "service_role_key client"
      pattern: "SUPABASE_SERVICE_ROLE_KEY"
---

<objective>
Create database schema migration and Edge Function code for job caching. This plan prepares all artifacts locally; deployment happens in Plan 02.

Purpose: Splits the complex backend setup into two focused plans - this one creates the code, next one deploys and wires it up.

Output: Migration SQL file with full JSearch schema, Edge Function code ready for deployment.
</objective>

<execution_context>
@C:\Users\thedi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\thedi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02.5-backend-job-caching/02.5-CONTEXT.md

@src/types/job.ts
@src/services/jsearch.ts
@src/services/clickTracker.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database schema migration for full JSearch fields + caching</name>
  <files>supabase/migrations/20260202_add_job_caching.sql</files>
  <action>
Create SQL migration file that adds ALL JSearch fields plus caching columns to the jobs table.

IMPORTANT: Phase 2 created a minimal jobs table with only (job_id, click_count, lane). This migration must add ALL missing JSearch fields.

1. **Add JSearch job fields** (these do NOT exist yet):
   ```sql
   -- Core job fields (required)
   ALTER TABLE jobs ADD COLUMN IF NOT EXISTS job_title TEXT;
   ALTER TABLE jobs ADD COLUMN IF NOT EXISTS employer_name TEXT;
   ALTER TABLE jobs ADD COLUMN IF NOT EXISTS job_city TEXT;
   ALTER TABLE jobs ADD COLUMN IF NOT EXISTS job_state TEXT;
   ALTER TABLE jobs ADD COLUMN IF NOT EXISTS job_country TEXT;
   ALTER TABLE jobs ADD COLUMN IF NOT EXISTS job_apply_link TEXT;

   -- Salary fields (optional, nullable)
   ALTER TABLE jobs ADD COLUMN IF NOT EXISTS job_min_salary NUMERIC;
   ALTER TABLE jobs ADD COLUMN IF NOT EXISTS job_max_salary NUMERIC;
   ALTER TABLE jobs ADD COLUMN IF NOT EXISTS job_salary_currency TEXT;
   ALTER TABLE jobs ADD COLUMN IF NOT EXISTS job_salary_period TEXT;

   -- Additional job info (optional)
   ALTER TABLE jobs ADD COLUMN IF NOT EXISTS employer_logo TEXT;
   ALTER TABLE jobs ADD COLUMN IF NOT EXISTS job_description TEXT;
   ```

2. **Add caching control columns**:
   ```sql
   -- Caching columns
   ALTER TABLE jobs ADD COLUMN IF NOT EXISTS is_active BOOLEAN DEFAULT TRUE NOT NULL;
   ALTER TABLE jobs ADD COLUMN IF NOT EXISTS last_seen TIMESTAMPTZ DEFAULT NOW();
   ```

3. **Add performance index**:
   ```sql
   CREATE INDEX IF NOT EXISTS idx_jobs_is_active ON jobs(is_active);
   ```

4. **Add column comments** for documentation

Use IF NOT EXISTS patterns throughout for idempotent migrations.

DO NOT modify click_count or lane columns - these must be preserved from existing engagement data.
  </action>
  <verify>
File exists at `supabase/migrations/20260202_add_job_caching.sql` with:
- ALTER TABLE statements for all JSearch fields (job_title, employer_name, etc.)
- ALTER TABLE for is_active and last_seen
- CREATE INDEX for idx_jobs_is_active
- All statements use IF NOT EXISTS pattern
  </verify>
  <done>
- Migration file exists with all JSearch fields
- Migration file includes caching columns (is_active, last_seen)
- Migration file is idempotent (safe to run multiple times)
- click_count and lane columns NOT touched
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Supabase Edge Function for job sync</name>
  <files>supabase/functions/job-sync/index.ts</files>
  <action>
Create the Edge Function following Deno runtime conventions:

1. **Initialize directory structure**:
   - Create `supabase/` directory if not exists
   - Create `supabase/functions/job-sync/` directory

2. **Create `index.ts`** with Deno-compatible code:

```typescript
// Import from esm.sh for Deno compatibility (NOT npm imports)
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

// Type definitions matching src/types/job.ts
interface JSearchJob {
  job_id: string;
  job_title: string;
  employer_name: string;
  job_city: string;
  job_state: string;
  job_country: string;
  job_apply_link: string;
  job_min_salary?: number;
  job_max_salary?: number;
  job_salary_currency?: string;
  job_salary_period?: string;
  employer_logo?: string;
  job_description?: string;
}
```

3. **Implement Deno.serve() handler**:
   - Create Supabase client with SUPABASE_SERVICE_ROLE_KEY (bypasses RLS)
   - Fetch jobs from JSearch API using native fetch (NOT axios)
   - Query: `fast+food+crew+member+USA`, num_pages=1
   - Mark all existing active jobs as inactive first
   - Upsert jobs with onConflict: 'job_id', setting is_active: true, last_seen: new Date()
   - Do NOT include click_count or lane in upsert (preserves existing values)
   - Return JSON response with success status, job count, timestamp

4. **Implement fetchWithRetry helper**:
   - Max 3 retries
   - Exponential backoff: 100ms, 200ms, 400ms + jitter (30%)
   - Only retry on 429 (rate limit) or 5xx errors
   - Log attempt count for debugging

5. **Error handling**:
   - Catch all errors
   - Return 500 with error message JSON
   - Log errors with [job-sync] prefix

6. **Environment variables** (via Deno.env.get()):
   - SUPABASE_URL (auto-injected by Supabase)
   - SUPABASE_SERVICE_ROLE_KEY (auto-injected by Supabase)
   - JSEARCH_API_KEY (must be added as secret before deployment)

CRITICAL: Use native `fetch`, NOT axios. Axios is incompatible with Deno runtime.
  </action>
  <verify>
File exists at `supabase/functions/job-sync/index.ts` with:
- Deno.serve() handler
- esm.sh import for supabase-js (not npm)
- Native fetch for JSearch API
- Upsert logic without click_count/lane
- Error handling with 500 response
  </verify>
  <done>
- supabase/functions/job-sync/index.ts exists
- Function uses Deno.serve() pattern
- Function uses native fetch (not axios)
- Function uses esm.sh imports (not npm)
- Upsert preserves click_count and lane (not included in payload)
- Error handling returns 500 with JSON error
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Database migration SQL and Edge Function code for job caching:
- Migration adds all JSearch fields to jobs table
- Migration adds caching columns (is_active, last_seen)
- Edge Function fetches from JSearch API and upserts to Supabase
- All code ready for deployment in Plan 02
  </what-built>
  <how-to-verify>
1. **Review migration file**:
   - Open `supabase/migrations/20260202_add_job_caching.sql`
   - Verify all JSearch fields are present (job_title, employer_name, job_city, job_state, job_country, job_apply_link, salary fields, employer_logo, job_description)
   - Verify caching columns (is_active, last_seen)
   - Verify IF NOT EXISTS patterns for idempotency

2. **Review Edge Function code**:
   - Open `supabase/functions/job-sync/index.ts`
   - Verify Deno.serve() pattern
   - Verify esm.sh imports (not npm)
   - Verify native fetch (not axios)
   - Verify upsert does NOT include click_count or lane

3. **Code builds**:
   - Run `npm run build` to ensure no TypeScript errors in main app
   - (Edge Function uses Deno, not Node - will be validated during deployment)
  </how-to-verify>
  <resume-signal>Type "approved" if files look correct, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:
1. Migration file exists with all JSearch fields
2. Migration file is idempotent (IF NOT EXISTS patterns)
3. Edge Function code compiles for Deno runtime
4. No click_count/lane in upsert operations
5. Ready for deployment in Plan 02
</verification>

<success_criteria>
- Database schema migration file complete with all JSearch fields
- Edge Function code ready for deployment
- All code follows Deno conventions (esm.sh imports, native fetch)
- User has reviewed and approved files
</success_criteria>

<output>
After completion, create `.planning/phases/02.5-backend-job-caching/02.5-01-SUMMARY.md`
</output>
